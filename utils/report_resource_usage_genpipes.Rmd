---
title: "optimize_resources_report.Rmd"
date: "`r Sys.Date()`"
editor_options:
  chunk_output_type: console
params: 
   input: NULL
   output: NULL
   timestamp: NULL
   name: NULL
   verbose: NULL
   scheduler: NULL
   threads: 1
output:
  html_document:
    toc: yes
    toc_float: true
    code_folding: hide
    df_print: paged
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
# Load libraries
suppressMessages({
  library(dplyr)
  library(data.table)
  library(lubridate)
  library(hms)
  library(ggplot2)
  library(plotly)
  library(highcharter)
  library(parallel)
  library(knitr)
})

# Set chunk options
knitr::opts_chunk$set(message=FALSE, warning=FALSE, results="asis")

# Assign parameters
input <- params$input
timestamp <- params$timestamp
output <- params$output
name_doc <- params$name
verbose <- params$verbose
scheduler <- params$scheduler
threads <- params$threads
```

```{r helper-functions, echo=FALSE}

# Add leading zero to time components
add_0_time <- function(number) {
  if (is.na(number)) return("00")
  sprintf("%02d", as.integer(number))
}

# Convert D-H:M:S to H:M:S
day_into_hours <- function(times) {
  sapply(times, function(time) {
    if (is.na(time) || !grepl("^(\\d+-)?\\d{1,2}:\\d{2}:\\d{2}$", time)) return(NA)
    
    parts <- strsplit(time, "-")[[1]]
    if (length(parts) == 1) {
      hms_parts <- strsplit(parts[1], ":")[[1]]
      if (length(hms_parts) != 3) return(NA)
      return(sprintf("%02d:%02d:%02d", as.integer(hms_parts[1]), as.integer(hms_parts[2]), as.integer(hms_parts[3])))
    } else {
      days <- as.integer(parts[1])
      hms_parts <- strsplit(parts[2], ":")[[1]]
      if (length(hms_parts) != 3) return(NA)
      hours <- days * 24 + as.integer(hms_parts[1])
      return(sprintf("%02d:%02d:%02d", hours, as.integer(hms_parts[2]), as.integer(hms_parts[3])))
    }
  })
}

# Convert decimal minutes to H:M:S
ChangeWaitingTimeFormat <- function(times) {
  sapply(times, function(t) {
    if (is.na(t)) return(NA)
    total_min <- as.numeric(t)
    h <- floor(total_min / 60)
    m <- floor(total_min %% 60)
    s <- round((total_min - floor(total_min)) * 60)
    paste(add_0_time(h), add_0_time(m), add_0_time(s), sep = ":")
  })
}

# Convert string to hms
String_to_Date <- function(stringD) {
  if (is.na(stringD)) return(NA)
  hms::as_hms(strsplit(stringD, "T")[[1]][2])
}

# Mean value for numeric or hms
mean_value <- function(vec) {
  if (is.character(vec)) {
    valid_times <- grep("^\\d{1,3}:\\d{2}:\\d{2}$", vec, value = TRUE)
    safe_hms <- lapply(valid_times, function(x) {
      tryCatch(hms::as_hms(x), error = function(e) NA)
    })
    safe_hms <- unlist(safe_hms)
    safe_hms <- safe_hms[!is.na(safe_hms)]

    if (length(safe_hms) == 0) {
      return(hms::as_hms("00:00:00"))  # Return a valid hms object
    }

    mean_time <- mean(as.numeric(safe_hms), na.rm = TRUE)
    return(hms::as_hms(mean_time))
  } else {
    result <- mean(vec, na.rm = TRUE)
    if (is.nan(result)) return(NA_real_)  # Ensure numeric NA is returned
    return(result)
  }
}

# Extract time unit for plotting
Keep_hour <- function(df, df2 = NULL) {
  # Filter valid HH:MM:SS strings
  df <- df[!is.na(df) & grepl("^\\d{1,3}:\\d{2}:\\d{2}$", df)]
  if (length(df) == 0) return(NA)

  # Safely convert to hms
  safe_hms <- suppressWarnings(tryCatch(hms::as_hms(df), error = function(e) NA))
  if (all(is.na(safe_hms))) return(NA)

  max_time <- max(safe_hms, na.rm = TRUE)

  # Ensure max_time is an hms object
  if (!inherits(max_time, "hms")) return(NA)

  if (lubridate::hour(max_time) > 0) {
    df <- lubridate::hour(safe_hms)
    if (!is.null(df2)) df2 <- lubridate::hour(hms::as_hms(df2))
    unit <- "hour"
  } else if (lubridate::minute(max_time) > 0) {
    df <- lubridate::hour(safe_hms) * 60 + lubridate::minute(safe_hms)
    if (!is.null(df2)) df2 <- lubridate::hour(hms::as_hms(df2)) * 60 + lubridate::minute(hms::as_hms(df2))
    unit <- "minute"
  } else {
    df <- as.numeric(safe_hms)
    if (!is.null(df2)) df2 <- as.numeric(hms::as_hms(df2))
    unit <- "second"
  }

  if (is.null(df2)) {
    return(list(df, unit))
  } else {
    return(list(df, df2, unit))
  }
}
```

```{r parallel-parsing, echo=FALSE}

# --- Scheduler-specific parsing functions ---

parse_slurm_file <- function(file_path) {
  tryCatch({
    lines <- readLines(file_path, warn = FALSE)
    start_idx <- grep("EPILOGUE", lines)
    if (length(start_idx) == 0) return(NULL)
    content <- lines[(start_idx[1] + 1):length(lines)]
    content <- unlist(strsplit(paste(content, collapse = " "), " "))

    get_val <- function(key) {
      val <- grep(key, content, value = TRUE)
      if (length(val) == 0) return(NA)
      strsplit(val, "=")[[1]][2]
    }

    job_name <- strsplit(get_val("JobName"), "\\.")[[1]][1]
    eligible <- String_to_Date(get_val("EligibleTime"))
    start <- String_to_Date(get_val("StartTime"))
    waiting <- as.numeric(difftime(start, eligible, units = "mins"))
    run_time <- get_val("RunTime")
    time_limit <- get_val("TimeLimit")
    cpus <- as.numeric(get_val("NumCPUs"))
    job_id <- get_val("JobId")

    # Call seff
    seff_out <- tryCatch({
      seff_resp <- system2("seff", args = job_id, stdout = TRUE)
      mem_line <- grep("Memory Efficiency", seff_resp, value = TRUE)
      mem_eff <- as.numeric(gsub("%", "", strsplit(mem_line, " +")[[1]][3]))
      mem_req <- as.numeric(strsplit(mem_line, " +")[[1]][5])
      c(mem_eff, mem_req)
    }, error = function(e) c(NA, NA))

    return(data.table(
      JobName = job_name,
      WaitingTime = waiting,
      RunTime = run_time,
      TimeLimit = time_limit,
      NumCPUs = cpus,
      Memory_Efficiency = seff_out[1],
      Memory_Request = seff_out[2]
    ))
  }, error = function(e) NULL)
}

parse_pbs_file <- function(file_path) {
  tryCatch({
    lines <- readLines(file_path, warn = FALSE)
    start_idx <- grep("Epilogue", lines)
    if (length(start_idx) == 0) return(NULL)
    content <- lines[(start_idx[1] + 1):length(lines)]
    content <- unlist(strsplit(paste(content, collapse = " "), " "))

    get_val <- function(key) {
      val <- grep(key, content, value = TRUE)
      if (length(val) == 0) return(NA)
      val[length(val)]
    }

    job_name <- strsplit(get_val("Name:"), "\\.")[[1]][1]
    run_time <- tail(strsplit(get_val("Resources"), "=")[[1]], 1)
    time_limit <- tail(strsplit(get_val("Limits"), "=")[[1]], 1)
    cpus <- as.numeric(strsplit(strsplit(get_val("Limits"), "=")[[1]][2], ":")[[1]][1])
    mem_kb <- as.numeric(gsub("kb", "", strsplit(get_val("Resources"), "=")[[1]][4]))
    mem_gb <- signif(mem_kb / 1e6, 2)
    job_id <- strsplit(strsplit(get_val("ID"), ":")[[1]][2], "\\.")[[1]][1]
    mem_limit <- cpus * 5
    mem_eff <- (mem_gb / mem_limit) * 100

    waiting <- tryCatch({
      checkjob <- system2("checkjob", args = job_id, stdout = TRUE)
      line <- grep("Time Queued  Total:", checkjob, value = TRUE)
      gsub(")", "", strsplit(line, " +")[[1]][10])
    }, error = function(e) NA)

    return(data.table(
      JobName = job_name,
      WaitingTime = waiting,
      RunTime = run_time,
      TimeLimit = time_limit,
      NumCPUs = cpus,
      Memory_Efficiency = mem_eff,
      Memory_Request = mem_gb
    ))
  }, error = function(e) NULL)
}

# --- Main parsing function ---

parsed_folder <- function(job_output_path, timestamp = NULL) {
  folders <- list.dirs(job_output_path, recursive = FALSE, full.names = TRUE)
  pattern <- if (!is.null(timestamp)) paste0("*", timestamp, ".o") else "*.o"
  file_paths <- unlist(lapply(folders, function(path) {
    list.files(path, pattern = pattern, recursive = TRUE, full.names = TRUE)
  }))

  parse_fun <- if (scheduler == "SLURM") parse_slurm_file else parse_pbs_file
  parsed <- mclapply(file_paths, parse_fun, mc.cores = max(1, as.integer(params$threads)))
  parsed <- rbindlist(parsed, fill = TRUE)

  # Format time columns
  parsed$TimeLimit <- day_into_hours(parsed$TimeLimit)
  parsed$RunTime <- day_into_hours(parsed$RunTime)
  parsed$WaitingTime <- ChangeWaitingTimeFormat(parsed$WaitingTime)

  # For plotting
  DF_plot <- copy(parsed)

  # Aggregate by JobName
  Info_df <- parsed[, .(
    WaitingTime = mean_value(WaitingTime),
    RunTime = mean_value(RunTime),
    TimeLimit = mean_value(TimeLimit),
    NumCPUs = mean_value(NumCPUs),
    Memory_Efficiency = mean_value(Memory_Efficiency),
    Memory_Request = mean_value(Memory_Request)
  ), by = JobName]

  return(list(Info_df, DF_plot))
}
```

```{r data-aggregation-export, echo=FALSE}

# Run the parsing function
result <- parsed_folder(input, timestamp)
Info_df <- result[[1]]
DF_plot <- result[[2]]

# Create timestamped filename
actual_date_time <- format(Sys.time(), "%Y-%m-%dT%H.%M.%S")
file_name <- paste(name_doc, actual_date_time, sep = "_")
csv_path <- file.path(output, paste0(file_name, ".csv"))

# Save summary table
fwrite(Info_df, csv_path)

# Optional verbose output
if (verbose) {
  cat("## Verbose Output\n")
  cat(paste0("**", nrow(DF_plot), "** files parsed.\n\n"))
  cat(paste0("**", nrow(Info_df), "** unique steps identified.\n\n"))
  cat(paste0("Input path: **", input, "**\n\n"))
  cat(paste0("Timestamp filter: **", timestamp, "**\n\n"))
  cat(paste0("Scheduler: **", scheduler, "**\n\n"))
}
```

```{r plotting, echo=FALSE, fig.height=10, out.width='100%'}

# --- Waiting Time Plot ---
waiting_plot <- NULL
waiting_flag <- FALSE

if (!is.na(Keep_hour(DF_plot$WaitingTime)[1])) {
  waiting_data <- Keep_hour(DF_plot$WaitingTime)
  DF_plot$WaitingTime <- waiting_data[[1]]
  waiting_unit <- waiting_data[[2]]
  waiting_flag <- TRUE

  dat1 <- data_to_boxplot(
    data = DF_plot,
    variable = WaitingTime,
    group_var = JobName,
    name = paste("WaitingTime (", waiting_unit, ")", sep = "")
  )

  waiting_plot <- highchart() %>%
    hc_xAxis(type = "category") %>%
    hc_add_series_list(dat1) %>%
    hc_chart(type = "bar", height = "800px")
} else {
  cat("**WaitingTime plot hasn't been displayed since no values have been found.**\n\n")
}

# --- Run Time & Efficiency Plot ---
run_limit <- Keep_hour(DF_plot$RunTime, DF_plot$TimeLimit)
DF_plot$RunTime <- run_limit[[1]]
DF_plot$TimeLimit <- run_limit[[2]]
time_unit <- run_limit[[3]]

DF_plot$RunTime_Efficiency <- round((DF_plot$RunTime / DF_plot$TimeLimit) * 100, 1)

# Compute max efficiency per job
DF_max_Eff <- DF_plot[, .SD[which.max(RunTime_Efficiency)], by = JobName]
DF_plot <- merge(DF_plot, DF_max_Eff, by = "JobName", suffixes = c("", ".y"))

dat_run <- data_to_boxplot(
  data = DF_plot,
  variable = RunTime,
  group_var = JobName,
  name = paste("RunTime (", time_unit, ")", sep = "")
)

dat_eff <- data_to_boxplot(
  data = DF_plot,
  variable = RunTime_Efficiency.y,
  group_var = JobName,
  name = "RunTime_Efficiency (%)"
)

run_plot <- highchart() %>%
  hc_xAxis(type = "category") %>%
  hc_add_series_list(dat_run) %>%
  hc_add_series_list(dat_eff) %>%
  hc_chart(type = "bar")

# --- Memory Plot ---
DF_plot$Memory_Request <- as.numeric(DF_plot$Memory_Request)

dat_mem <- data_to_boxplot(
  data = DF_plot,
  variable = Memory_Request,
  group_var = JobName,
  name = "Memory_Request (GB)"
)

if (scheduler == "SLURM" && all(!is.na(DF_plot$Memory_Efficiency))) {
  dat_eff_mem <- data_to_boxplot(
    data = DF_plot,
    variable = Memory_Efficiency,
    group_var = JobName,
    name = "Memory_Efficiency (%)"
  )

  mem_plot <- highchart() %>%
    hc_xAxis(type = "category") %>%
    hc_add_series_list(dat_mem) %>%
    hc_add_series_list(dat_eff_mem) %>%
    hc_chart(type = "bar")
} else {
  cat("**Memory efficiency not available for PBS or missing values. Showing only memory request.**\n\n")
  mem_plot <- highchart() %>%
    hc_xAxis(type = "category") %>%
    hc_add_series_list(dat_mem) %>%
    hc_chart(type = "bar")
}

# Display plots
if (waiting_flag) waiting_plot
run_plot
mem_plot
```

```{r final-summary, echo=FALSE}

cat("\n---\n")
cat("### Report Summary\n")

cat(paste0("- **Total files parsed**: ", nrow(DF_plot), "\n"))
cat(paste0("- **Unique job steps**: ", nrow(Info_df), "\n"))
cat(paste0("- **Scheduler used**: ", scheduler, "\n"))
cat(paste0("- **Timestamp filter**: ", ifelse(is.null(timestamp), "None", timestamp), "\n"))
cat(paste0("- **Report generated on**: ", Sys.time(), "\n"))
cat(paste0("- **Output saved to**: ", csv_path, "\n"))
```
